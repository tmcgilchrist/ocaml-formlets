(* Common aspects of formlets implementations. *)

open Basics

(* CGI environments *)
type environment = (string * string) list

(*
  XML, and how to print it.
*)
module Xml =
struct
  type xml_item = Text of string | Tag of tag * attributes * xml
   and tag = string
   and attributes = (string * string) list
   and xml = xml_item list

  let escape s = 
    Str.global_replace (Str.regexp "<") "&lt;" 
      (Str.global_replace (Str.regexp "&") "&amp;" s)

  let rec to_string xml : string
      = String.concat "" (List.map string_of_item xml)
  and string_of_item : xml_item -> string = 
    let escape = Str.global_replace (Str.regexp "\"") "\\\""  in
    let format_attr (k, v) = k ^ "=\"" ^ escape v ^ "\"" in
    let format_attrs attrs = match String.concat " " (List.map format_attr attrs) with 
      | "" -> ""
      | a -> " " ^ a in
      function
        | Text s -> escape s
        | Tag (tag, attrs, nodes) -> 
            match nodes with 
              | [] -> "<" ^ tag ^ format_attrs attrs ^ "/>"
              | _  -> ("<" ^ tag ^ format_attrs attrs ^ ">" 
                       ^ to_string nodes
                       ^ "</" ^ tag ^ ">")

  let xml_text x = [Text x]
  let xml_tag t a x = [Tag (t, a, x)]
end


(* 
   The name-generation idiom.

   This is the idiom generated by the state monad.

   It is interesting to note that the "get" and "put" operations of
   the state monad cannot be used to write next_name in the idiom
   because of obliviousness.  We must instead provide next_name as a
   primitive effect.
*)
module NameGen : 
sig
  include Idiom

  val next_name : string t
  val run : 'a t -> 'a
end =
struct
  type gen = int
  type 'a t = gen -> 'a * gen
  let pure v gen = (v, gen)
  let (<*>) f a gen = 
    let v, gen = f gen in
    let w, gen = a gen in
      v w, gen

  let next_name gen = "input_" ^ string_of_int gen, gen + 1
  let run c = fst (c 0)
end


(* 
   The accumulation idiom over the monoid of XML forests.
*)
module XmlWriter :
sig
  include Idiom

  val text : string -> unit t
  val xml : Xml.xml -> unit t
  val tag : Xml.tag -> Xml.attributes -> 'a t -> 'a t
  val run : 'a t -> Xml.xml * 'a
end =
struct
  open Xml
  type 'a t = Xml.xml * 'a

  let pure v = ([], v)
  let (<*>) (x,f) (y,a) = (x @ y, f a)
  let plug k (x,v) = (k x, v)
  let xml e = plug (fun _ -> e) (pure ())
  let text s = xml [Text s]
  let tag t ats v = plug (fun x -> [Tag (t, ats, x)]) v
  let run = id
end

(* 
   The environment (or state-reader) idiom, with CGI environments as
   the state type.
*)
module Environment :
sig
  include Idiom

  val lookup : string -> string t
  val run : 'a t -> environment -> 'a
end =
struct
  type env = (string * string) list
  type 'a t = env -> 'a

  let pure v env = v
  let (<*>) f a env = f env (a env)

  let rec lookup n = function
    | []                    -> failwith ("Not found : " ^ n)
    | (m,v)::_   when n = m -> v
    | _    ::env            -> lookup n env

  let run = id
end


(*
  Running and rendering
*)
let pickle_cont (k : environment -> Xml.xml) : string = 
  Netencoding.Base64.encode (Marshal.to_string k [Marshal.Closures])

let unpickle_cont (s : string) : environment -> Xml.xml =
  Marshal.from_string (Netencoding.Base64.decode s) 0

let run mkPage = 
  let () = print_endline "Content-type: text/html\n" in
    try 
      let args = Cgi.parse_args () in
        match (List.partition (fun (name, v) -> name = "_k") args)
        with
          | [_, conts], args ->
              let cont = unpickle_cont conts in
                print_endline (Xml.to_string (cont args))
          | _ -> raise Not_found
    with Not_found -> print_endline (Xml.to_string (mkPage ()))
      | Failure x -> let () = prerr_endline ("failure : " ^ x) in print_endline (Xml.to_string (mkPage ()))
